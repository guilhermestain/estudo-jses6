{"ast":null,"code":"// Blacklist common values.\nconst BLACKLIST = [\"00000000000\", \"11111111111\", \"22222222222\", \"33333333333\", \"44444444444\", \"55555555555\", \"66666666666\", \"77777777777\", \"88888888888\", \"99999999999\", \"12345678909\"];\nconst STRICT_STRIP_REGEX = /[.-]/g;\nconst LOOSE_STRIP_REGEX = /[^\\d]/g;\n/**\n * Compute the Verifier Digit (or \"DÃ­gito Verificador (DV)\" in PT-BR).\n *\n * You can learn more about the algorithm on [wikipedia (pt-br)](https://pt.wikipedia.org/wiki/D%C3%ADgito_verificador)\n *\n * @export\n * @param {string} numbers a string with only numbers.\n * @returns {number} the verifier digit.\n */\n\nexport function verifierDigit(numbers) {\n  numbers = numbers.split(\"\").map(function (number) {\n    return parseInt(number, 10);\n  });\n  const modulus = numbers.length + 1;\n  const multiplied = numbers.map(function (number, index) {\n    return number * (modulus - index);\n  });\n  const mod = multiplied.reduce(function (buffer, number) {\n    return buffer + number;\n  }) % 11;\n  return mod < 2 ? 0 : 11 - mod;\n}\n/**\n * Transform the input into a pretty CPF format.\n *\n * Example:\n * ```\n * format('12345678901');\n * // Result: '123.456.789-01'\n * ```\n *\n * @export\n * @param {string} cpf the CPF.\n * @returns {string} the formatted CPF.\n */\n\nexport function format(cpf) {\n  return strip(cpf).replace(/^(\\d{3})(\\d{3})(\\d{3})(\\d{2})$/, \"$1.$2.$3-$4\");\n}\n/**\n * Remove some characters from the `number` input.\n *\n * Example:\n * ```\n * strip('29537995593'); // Result: '29537995593'\n * strip('295.379.955-93'); // Result: '29537995593'\n * strip('295a379b9c5d59e3'); // Result: '29537995593'\n * strip('295a379b9c5d59e3', true); // Result: '295a379b9c5d59e3' - Atention!\n * ```\n *\n * @export\n * @param {string} cpf the CPF text.\n * @param {boolean} [isStrict] if `true`, it will remove only `.` and `-` characters.\n *                             Otherwise, it will remove all non-digit (`[^\\d]`) characters. Optional.\n * @returns {string} the stripped CPF.\n */\n\nexport function strip(cpf, isStrict) {\n  const regex = isStrict ? STRICT_STRIP_REGEX : LOOSE_STRIP_REGEX;\n  return (cpf || \"\").toString().replace(regex, \"\");\n}\n/**\n * Validate the CPF.\n *\n * @export\n * @param {string} cpf the CPF number.\n * @param {boolean} [isStrict] if `true`, it will accept only `digits`, `.` and `-` characters. Optional.\n * @returns {boolean} `true` if CPF is valid. Otherwise, `false`.\n */\n\nexport function isValid(cpf, isStrict) {\n  const stripped = strip(cpf, isStrict); // CPF must be defined\n\n  if (!stripped) {\n    return false;\n  } // CPF must have 11 chars\n\n\n  if (stripped.length !== 11) {\n    return false;\n  } // CPF can't be blacklisted\n\n\n  if (BLACKLIST.includes(stripped)) {\n    return false;\n  }\n\n  let numbers = stripped.substr(0, 9);\n  numbers += verifierDigit(numbers);\n  numbers += verifierDigit(numbers);\n  return numbers.substr(-2) === stripped.substr(-2);\n}\n/**\n * Generate a random CPF.\n *\n * @export\n * @param {boolean} [useFormat] if `true`, it will format using `.` and `-`. Optional.\n * @returns {string} the CPF.\n */\n\nexport function generate(useFormat) {\n  let numbers = \"\";\n\n  for (let i = 0; i < 9; i += 1) {\n    numbers += Math.floor(Math.random() * 9);\n  }\n\n  numbers += verifierDigit(numbers);\n  numbers += verifierDigit(numbers);\n  return useFormat ? format(numbers) : numbers;\n}","map":null,"metadata":{},"sourceType":"module"}